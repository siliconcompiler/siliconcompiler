import os

import difflib
import shutil
import logging

import os.path

from datetime import datetime
from typing import Set, Tuple, Optional, TYPE_CHECKING

from siliconcompiler.schema_support.pathschema import PathSchemaSimpleBase
from siliconcompiler.schema import NamedSchema, EditableSchema, Parameter, Scope
from siliconcompiler.schema.utils import trim
from siliconcompiler.utils import sc_open

if TYPE_CHECKING:
    from siliconcompiler import Design


class Patch(NamedSchema, PathSchemaSimpleBase):
    '''
    Schema for a 'patch'.
    '''

    def __init__(self, name: Optional[str] = None):
        '''
        Initializes a new Patch object. The optional name argument is not
        currently used, but is included for future expansion.
        '''
        super().__init__()
        self.set_name(name)

        schema = EditableSchema(self)
        schema.insert(
            'file',
            Parameter(
                'file',
                scope=Scope.GLOBAL,
                copy=True,
                shorthelp="File to patch",
                help="""File to apply a patch to."""))

        schema.insert(
            'diff',
            Parameter(
                'str',
                scope=Scope.GLOBAL,
                shorthelp="Unified diff for patch",
                help=trim("""The patch content in unified diff format.
            This format describes the differences between an original and a
            modified file using a compact representation. It is the format
            generated by `difflib.unified_diff()`.

            The unified diff format shows changed sections with context lines,
            using '+' for added lines, '-' for removed lines, and ' ' for
            context lines. Header lines starting with '---', '+++', and '@@'
            provide metadata (which can be ignored when applying).

            You can generate this diff text using the `create_from_files()`
            method.""")))

    def apply(self, logger: Optional[logging.Logger] = None) -> None:
        """
        Applies a unified diff patch to a file.
        This avoids dependencies on external command-line tools.

        Raises:
            FileNotFoundError: If the file to patch does not exist.
            ValueError: If no diff text is found for this patch.
            IOError: If the patched file could not be written or patch could not be applied.
        """
        diff_text = self.get('diff')
        if not diff_text:
            raise ValueError("No diff text found for this patch.")

        file_to_patch = self.find_files('file')
        if logger:
            logger.info(f"Applying patch ({self.name}) to file: {self.get('file')}")

        original_mtime = None

        # Create a backup
        if not os.path.exists(f"{file_to_patch}.sc_orig_patch"):
            original_mtime = os.path.getmtime(file_to_patch)
            try:
                shutil.copy(file_to_patch, f"{file_to_patch}.sc_orig_patch")
            except Exception as e:
                raise IOError(f"Could not create backup for {file_to_patch}: {e}")
        else:
            original_mtime = os.path.getmtime(f"{file_to_patch}.sc_orig_patch")

        # Read the original file
        try:
            with sc_open(f"{file_to_patch}.sc_orig_patch", newline='') as f:
                original_lines = f.readlines()
        except Exception as e:
            raise IOError(f"Could not read file to patch: {file_to_patch} - {e}")

        # Apply the unified diff patch
        try:
            patched_lines = self._apply_unified_diff(original_lines, diff_text)
        except Exception as e:
            raise IOError(f"Could not apply patch: {e}")

        # Write the patched file
        try:
            with open(file_to_patch, 'w', newline='') as f:
                f.writelines(patched_lines)
            # Restore original modification time
            if original_mtime is not None:
                os.utime(file_to_patch, (original_mtime, original_mtime))
        except Exception as e:
            raise IOError(f"Could not write patched file: {file_to_patch} - {e}")

    def _apply_unified_diff(self, original_lines: list, diff_text: str) -> list:
        """
        Apply a unified diff to the original lines.

        Args:
            original_lines: List of lines from the original file
            diff_text: Unified diff text

        Returns:
            List of lines after applying the patch
        """
        result = []
        diff_lines = diff_text.splitlines(keepends=True)

        i = 0  # Index into original_lines (0-based)
        d = 0  # Index into diff_lines

        # Skip header lines (---, +++, etc.) until we find the first hunk
        while d < len(diff_lines):
            line = diff_lines[d]
            if line.startswith('@@'):
                break
            d += 1

        if d >= len(diff_lines):
            # No hunks found, return original
            return original_lines

        # Process hunks
        while d < len(diff_lines):
            line = diff_lines[d]

            if line.startswith('@@'):
                # Parse hunk header: @@ -old_start,old_count +new_start,new_count @@
                # Format: @@ -old_start,old_count +new_start,new_count @@
                parts = line.split()
                if len(parts) >= 3:
                    old_info = parts[1]  # -old_start,old_count
                    if old_info.startswith('-'):
                        old_start = int(old_info[1:].split(',')[0])
                        # Copy any lines we haven't processed yet (before this hunk)
                        # Note: old_start is 1-based, i is 0-based
                        while i < old_start - 1:
                            result.append(original_lines[i])
                            i += 1
                d += 1
                continue

            if line.startswith('-'):
                # Line removed from original - skip it in original, don't add to result
                i += 1
                d += 1
            elif line.startswith('+'):
                # Line added in new version - add to result (without the +), don't advance original
                result.append(line[1:])
                d += 1
            elif line.startswith(' '):
                # Context line - copy from original and advance both
                result.append(original_lines[i])
                i += 1
                d += 1
            elif line.strip() == '':
                # Empty line at end of diff
                d += 1
            else:
                # Unknown line type, skip
                d += 1

        # Copy any remaining lines from original
        while i < len(original_lines):
            result.append(original_lines[i])
            i += 1

        return result

    def create_from_files(self, original_file: str, modified_file: str) -> None:
        """
        Creates a delta from two files using difflib.ndiff and sets the diff field.

        Args:
            original_file (str): The path to the original file.
            modified_file (str): The path to the modified file.
        """
        with sc_open(original_file) as f:
            original_lines = f.readlines()
            original_file_time = os.path.getmtime(original_file)
        with sc_open(modified_file) as f:
            modified_lines = f.readlines()
            modified_file_time = os.path.getmtime(modified_file)

        timeformat = '%Y-%m-%d %H:%M:%S'

        self.set('diff', ''.join(
            difflib.unified_diff(
                original_lines, modified_lines,
                fromfile=original_file, tofile=modified_file,
                fromfiledate=datetime.fromtimestamp(original_file_time).strftime(timeformat),
                tofiledate=datetime.fromtimestamp(modified_file_time).strftime(timeformat))))

    @staticmethod
    def mark_patches_for_collection(design: "Design") -> bool:
        """
        Mark all files with patches in a fileset for collection.

        Finds all patches in the given fileset and marks their target files
        for collection by setting the copy flag.

        Args:
            design: The Design object containing the patches.

        Returns:
            bool: True if any files were marked for collection, False otherwise.
        """
        marked_any = False

        patch_files: Set[Tuple[Optional[str], str]] = set()

        for fileset in design.getkeys('fileset'):
            for patch_key in design.getkeys("fileset", fileset, "patch"):
                patch_obj = design.get("fileset", fileset, "patch", patch_key, field="schema")

                patch_file = patch_obj.get('file')
                if not patch_file:
                    continue

                file_dataroot = patch_obj.get('file', field='dataroot')
                patch_files.add((file_dataroot, patch_file))

        if not patch_files:
            return False

        # Search filesets for files matching the patches
        for fileset in design.getkeys('fileset'):
            for filetype in design.getkeys('fileset', fileset, 'file'):
                files = design.get('fileset', fileset, 'file', filetype)
                if not files:
                    continue

                file_dataroots = design.get('fileset', fileset, 'file', filetype,
                                           field='dataroot')

                for file_dataroot, file_name in zip(file_dataroots, files):
                    if (file_dataroot, file_name) in patch_files:
                        # Mark this file for collection
                        design.set('fileset', fileset, 'file', filetype, True, field="copy")
                        marked_any = True
                        break

            for dirkey in ('libdir', 'idir'):
                dirs = design.get('fileset', fileset, dirkey)
                dir_dataroots = design.get('fileset', fileset, dirkey, field='dataroot')
                for dir_dataroot, dir_name in zip(dir_dataroots, dirs):
                    for patch_dataroot, patch_file in patch_files:
                        if patch_dataroot is not None and patch_dataroot != dir_dataroot:
                            continue
                        if patch_file.startswith(dir_name):
                            # Mark this directory for collection
                            design.set('fileset', fileset, dirkey, True, field="copy")
                            marked_any = True
                            break

        return marked_any

    @staticmethod
    def apply_all_patches(design: "Design", logger: logging.Logger) -> None:
        """
        Apply all patches in a fileset to their target files in the collection directory.

        This method handles all aspects of patch application:
        - Finding patched files in the collection
        - Creating .orig backups on first application
        - Restoring patches to produce final files with timestamp preservation

        Args:
            design: The Design object containing the patches.
            fileset: The fileset name containing the patches.
            collection_dir: The collection directory where files have been collected.
            logger: Optional logger for debug/error messages.

        Raises:
            Various exceptions if patch application fails (logged and re-raised).
        """
        for fileset in design.getkeys('fileset'):
            for patch_key in design.getkeys("fileset", fileset, "patch"):
                patch_obj = design.get("fileset", fileset, "patch", patch_key, field="schema")
                if patch_obj.get("file") is None:
                    continue
                patch_obj.apply(logger)
