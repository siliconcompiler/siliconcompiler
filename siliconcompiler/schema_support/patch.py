import os
import difflib
import shutil

from datetime import datetime

from typing import Optional

from siliconcompiler.schema import NamedSchema, EditableSchema, Parameter, Scope
from siliconcompiler.schema.utils import trim
from siliconcompiler.utils import sc_open


class Patch(NamedSchema):
    '''
    Schema for a 'patch'.
    '''

    def __init__(self, name: Optional[str] = None):
        '''
        Initializes a new Patch object. The optional name argument is not
        currently used, but is included for future expansion.
        '''
        super().__init__()
        self.set_name(name)

        schema = EditableSchema(self)
        schema.insert(
            'file',
            Parameter(
                'str',
                scope=Scope.GLOBAL,
                shorthelp="File to patch",
                help=trim("""
            File to apply a patch to. The path is relative to the fileset root.""")))

        schema.insert(
            'dataroot',
            Parameter(
                'str',
                scope=Scope.GLOBAL,
                shorthelp="Data root for file to patch",
                help=trim("""
            The data root where the file to patch is located. This is typically the fileset root.""")))

        schema.insert(
            'diff',
            Parameter(
                'str',
                scope=Scope.GLOBAL,
                shorthelp="Unified diff for patch",
                help=trim("""The patch content in unified diff format.
            This format describes the differences between an original and a
            modified file using a compact representation. It is the format
            generated by `difflib.unified_diff()`.

            The unified diff format shows changed sections with context lines,
            using '+' for added lines, '-' for removed lines, and ' ' for
            context lines. Header lines starting with '---', '+++', and '@@'
            provide metadata (which can be ignored when applying).

            You can generate this diff text using the `create_from_files()`
            method.""")))

    def apply(self, file_to_patch: str) -> None:
        """
        Applies a unified diff patch to a file.
        This avoids dependencies on external command-line tools.

        Args:
            file_to_patch (str): The path to the file to be patched.

        Raises:
            FileNotFoundError: If the file to patch does not exist.
            ValueError: If no diff text is found for this patch.
            IOError: If the patched file could not be written or patch could not be applied.
        """
        diff_text = self.get('diff')
        if not diff_text:
            raise ValueError("No diff text found for this patch.")

        if not os.path.exists(file_to_patch):
            raise FileNotFoundError(f"File to patch does not exist: {file_to_patch}")

        # Create a backup
        if not os.path.exists(f"{file_to_patch}.orig"):
            try:
                shutil.copy(file_to_patch, f"{file_to_patch}.orig")
            except Exception as e:
                raise IOError(f"Could not create backup for {file_to_patch}: {e}")

        # Read the original file
        try:
            with open(f"{file_to_patch}.orig", 'r', newline='') as f:
                original_lines = f.readlines()
        except Exception as e:
            raise IOError(f"Could not read file to patch: {file_to_patch} - {e}")

        # Apply the unified diff patch
        try:
            patched_lines = self._apply_unified_diff(original_lines, diff_text)
        except Exception as e:
            raise IOError(f"Could not apply patch: {e}")

        # Write the patched file
        try:
            with open(file_to_patch, 'w', newline='') as f:
                f.writelines(patched_lines)
        except Exception as e:
            raise IOError(f"Could not write patched file: {file_to_patch} - {e}")

    def _apply_unified_diff(self, original_lines: list, diff_text: str) -> list:
        """
        Apply a unified diff to the original lines.
        
        Args:
            original_lines: List of lines from the original file
            diff_text: Unified diff text
            
        Returns:
            List of lines after applying the patch
        """
        result = []
        diff_lines = diff_text.splitlines(keepends=True)
        
        i = 0  # Index into original_lines (0-based)
        d = 0  # Index into diff_lines
        
        # Skip header lines (---, +++, etc.) until we find the first hunk
        while d < len(diff_lines):
            line = diff_lines[d]
            if line.startswith('@@'):
                break
            d += 1
        
        if d >= len(diff_lines):
            # No hunks found, return original
            return original_lines
        
        # Process hunks
        while d < len(diff_lines):
            line = diff_lines[d]
            
            if line.startswith('@@'):
                # Parse hunk header: @@ -old_start,old_count +new_start,new_count @@
                # Format: @@ -old_start,old_count +new_start,new_count @@
                parts = line.split()
                if len(parts) >= 3:
                    old_info = parts[1]  # -old_start,old_count
                    if old_info.startswith('-'):
                        old_start = int(old_info[1:].split(',')[0])
                        # Copy any lines we haven't processed yet (before this hunk)
                        # Note: old_start is 1-based, i is 0-based
                        while i < old_start - 1:
                            result.append(original_lines[i])
                            i += 1
                d += 1
                continue
            
            if line.startswith('-'):
                # Line removed from original - skip it in original, don't add to result
                i += 1
                d += 1
            elif line.startswith('+'):
                # Line added in new version - add to result (without the +), don't advance original
                result.append(line[1:])
                d += 1
            elif line.startswith(' '):
                # Context line - copy from original and advance both
                result.append(original_lines[i])
                i += 1
                d += 1
            elif line.strip() == '':
                # Empty line at end of diff
                d += 1
            else:
                # Unknown line type, skip
                d += 1
        
        # Copy any remaining lines from original
        while i < len(original_lines):
            result.append(original_lines[i])
            i += 1
        
        return result

    def create_from_files(self, original_file: str, modified_file: str) -> None:
        """
        Creates a delta from two files using difflib.ndiff and sets the diff field.

        Args:
            original_file (str): The path to the original file.
            modified_file (str): The path to the modified file.
        """
        with sc_open(original_file) as f:
            original_lines = f.readlines()
            original_file_time = os.path.getmtime(original_file)
        with sc_open(modified_file) as f:
            modified_lines = f.readlines()
            modified_file_time = os.path.getmtime(modified_file)
        
        timeformat = '%Y-%m-%d %H:%M:%S'

        self.set('diff', ''.join(
            difflib.unified_diff(
                original_lines, modified_lines,
                fromfile=original_file, tofile=modified_file,
                fromfiledate=datetime.fromtimestamp(original_file_time).strftime(timeformat),
                tofiledate=datetime.fromtimestamp(modified_file_time).strftime(timeformat))))
