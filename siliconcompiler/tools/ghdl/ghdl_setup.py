import os
import subprocess
import re
import sys
import json
import siliconcompiler

from siliconcompiler.schema_utils import schema_path

#####################################################################
# Make Docs
#####################################################################

def make_docs():
    '''
    GHDL, the open-source analyzer, compiler, simulator and
    (experimental) synthesizer for VHDL. It allows you to analyse 
    and elaborate sources for generating machine code from your design. 
    Native program execution is the only way for high speed simulation.

    Documentation: https://ghdl.readthedocs.io/en/latest

    Sources: https://github.com/ghdl/ghdl 

    Installation: https://github.com/ghdl/ghdl

    '''

    chip = siliconcompiler.Chip()
    setup_tool(chip,'spice','<index>')
    return chip

################################
# Setup Tool (pre executable)
################################

def setup_tool(chip, step, index):
    ''' Per tool function that returns a dynamic options string based on
    the dictionary settings.
    '''

    # Standard Setup
    tool = 'ghdl'
    clobber = False

    chip.set('eda', tool, step, index, 'threads', '4', clobber=clobber)
    chip.set('eda', tool, step, index, 'copy', 'false', clobber=clobber)
    chip.set('eda', tool, step, index, 'exe', 'yosys', clobber=clobber)
    chip.set('eda', tool, step, index, 'version', '0.0', clobber=clobber)

    # ghdl is invoked via Yosys by running a command with the format:
    #   yosys -m ghdl -p 'ghdl --std=08 --no-formal sources...; write_ilang ghdl.ilang'
    chip.add('eda', tool, step, index, 'option', 'cmdline', '-m ghdl')
    chip.add('eda', tool, step, index, 'option', 'cmdline', '-p \'ghdl')

    chip.add('eda', tool, step, index, 'option', 'cmdline', '--std=08')
    chip.add('eda', tool, step, index, 'option', 'cmdline', '--no-formal')

    # parameter overrides
    for value in chip.get('define'):
        chip.add('eda', tool, step, index, 'option', 'cmdline', '-g' + schema_path(value))

    # only use VHDL source files (*.vhd and *.vhdl)
    for value in  chip.get('source'):
        if value.endswith('.vhd') or value.endswith('.vhdl'):
            chip.add('eda', tool, step, index, 'option', 'cmdline', schema_path(value))

    # determine the top modules for the VHDL import:
    # if the `manifest.json` file is generated by a previous Verilog import,
    # then we use the undefined modules listed in that file as guesses for the
    # VHDL top modules.
    # if `manifest.json` is not found, we assume the design top lists the
    # single VHDL top module, and return an error if it is not defined.
    modules = ""
    try:
        with open("inputs/import/manifest.json", "r") as manifest:
            data = json.load(manifest)
            modules = " ".join(data["undefined"])
    except FileNotFoundError:
        pass

    if modules == "":
        if chip.get('design') == "":
            chip.logger.error('No top module set')
            return
        modules = chip.get('design')

    # pass the list of top modules to GHDL for elaboration
    chip.add('eda', tool, step, index, 'option', 'cmdline', '-e ' + modules)

    # generate a .ilang file (Yosys RTLIL) which can be read by Yosys during
    # synthesis along with the Verilog inputs
    chip.add('eda', tool, step, index, 'option', 'cmdline', '; write_ilang ghdl.ilang\'')

################################
# Post_process (post executable)
################################

def post_process(chip, step, index):
    ''' Tool specific function to run after step execution
    '''

    # top module must be defined, either autodetected by morty during SV import
    # or defined manually by the user
    topmodule = chip.get('design')
    # pass the RTLIL to the next step
    subprocess.run("cp ghdl.ilang " + "outputs/" + topmodule + ".ilang",
                   shell=True)

    # pass any pickled verilog file along as well
    # TODO: with a graph representation we may be able to remove this part so the
    # Verilog can be passed directly from the import step to the next step
    if os.path.isfile("inputs/import/" + topmodule + ".v"):
        subprocess.run("cp inputs/import/" + topmodule + ".v" + " outputs/", shell=True)

    return 0

##################################################
if __name__ == "__main__":

    # File being executed
    prefix = os.path.splitext(os.path.basename(__file__))[0]
    output = prefix + '.json'

    # create a chip instance
    chip = siliconcompiler.Chip()
    # load configuration
    setup_tool(chip, step='import', index='0')
    # write out results
    chip.writecfg(output)
