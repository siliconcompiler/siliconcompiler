#!/usr/bin/env python3
# # Instantiating a hardened module **A** twice in a module **B**
#
# Hardened modules allow predictable timing, efficient placement, and scalable
# hierarchical ASIC design.
#
# This tutorial demonstrates how to use siliconCompiler to harden a
# verilog module as a reusable macro, and then instantiate it multiple times in
# another module by:
#
# 1. Writing a simple verilog module **A**
#
# 2. Synthesizing, placing, and routing **A** using siliconCompiler
#
# 3. Packaging the resulting layout and timing models from **A** as a hard macro
#
# 4. Instantiating the hard macro **A** twice inside a second module **B**
#
# 5. Running the ASIC flow on module **B**
#
# All these steps are contained in the [python script](https://github.com/philiprbrenan/silicon_compiler_mod_A_in_mod_B/blob/main/silicon_compiler_mod_A_in_mod_B.py)  detailed below.
#
# To  run this script:<br>
#
# ```
# docker run --rm -v "$(pwd):/sc_work" \
#   ghcr.io/siliconcompiler/sc_runner:v0.35.3 \
#   python3 silicon_compiler_mod_A_in_mod_B.py
# ```
#
# The output will appear in: ``./build/B/job0/write.gds/0/outputs/B.png``
#
# ## Environment Setup
#
# Import the tools to be used:
#

if __name__ == "__main__":
  import os
  from pathlib import Path

  from siliconcompiler import Design, ASIC, StdCellLibrary
  from siliconcompiler.flows import asicflow
  from siliconcompiler.targets import skywater130_demo
  from siliconcompiler.schema_support.option import OptionSchema
  from siliconcompiler.tools import get_task
  from siliconcompiler.tools.klayout import KLayoutLibrary
  from siliconcompiler.tools.openroad import OpenROADStdCellLibrary
  from siliconcompiler.tools.openroad.write_data import WriteViewsTask
  from siliconcompiler.tools.yosys import YosysStdCellLibrary

#
# ## Parameters
#
# These parameters determine the size of the design and the names of the
# modules in the design.
#
  A = "A"                                                                       # Module A to be instantiated multiple times
  B = "B"                                                                       # Module B contains several uses of module A
  N =  8                                                                        # Width of each data path

  SIZE   = 300                                                                  # Size of die containing design
  BORDER =  10                                                                  # Border around core area
#
# ## Files used
#
# These files will contain the verilog generated by this script.
#
  workdir  = "."
  file_a   = os.path.join(workdir, f"{A}.v")                                    # Verilog for module A
  file_b   = os.path.join(workdir, f"{B}.v")                                    # Verilog for module B
  clk_file = os.path.join(workdir, "silicon_compiler_mod_A_in_mod_B.sdc")       # Clock definition
#
# ## Step 1: Create Verilog for module **A**
#
# **A** is a simple ``AND`` gate with a registered output triggered by the clock.
#
  verilog_a = f"""
  module {A}(
      input  wire          clk,
      input  wire[{N}-1:0] a,
      input  wire[{N}-1:0] b,
      output reg [{N}-1:0] y
  );

    always @ (posedge clk) begin
      y = a & b;
    end
  endmodule
  """

  with open(file_a, "w") as f:
    f.write(verilog_a)

  with open(clk_file, "w") as f:
      f.write(f"create_clock -name clk -period 100 [get_ports clk]\n")
#
# ## Step 2: Synthesize, Place & Route module **A**
#
# The following code will build module **A** with the siliconCompiler default
# ``ASIC`` flow:
#
  design_a = Design(A)

  design_a.set_dataroot(A, __file__)
  design_a.add_file(f"{A}.v", fileset='verilog')
  design_a.set_topmodule(A, fileset='verilog')

  project_a = ASIC(design_a)
  project_a.add_fileset(['verilog'])
  skywater130_demo(project_a)

  project_a.run()
  project_a.summary()
#
# ## Step 3: Create a Macro Library Class from **A**
#
# Take the generated ``LEF``, ``GDS``, and ``Liberty`` files and package them into a
# custom library class so **A** can be instantiated as a hard macro.
#
# Define a class that inherits from the relevant tools and
# provides them with the locations of the files generated by siliconCompiler
# during the processing of module **A**.
#
  class ModA(YosysStdCellLibrary, OpenROADStdCellLibrary, KLayoutLibrary):
    '''Module A definition'''
    def __init__(self, modA):
      '''Module A constructor'''
      super().__init__()
      self.set_name(f"mod{A}")

      self.add_asic_pdk(modA.get("asic", "pdk"))

      with self.active_fileset("models.physical"):
        self.add_file(f"./build/{A}/job0/write.views/0/outputs/{A}.lef")
        self.add_file(f"./build/{A}/job0/write.views/0/outputs/{A}.slow.lib")
        self.add_file(f"./build/{A}/job0/write.gds/0/outputs/{A}.gds")
        self.add_asic_aprfileset()

      with self.active_fileset("models.timing.nldm"):
        self.add_file(f"./build/{A}/job0/write.views/0/outputs/{A}.slow.lib")
        self.add_asic_libcornerfileset("generic", "nldm")
#
# ## Step 4: Create Verilog for a module **B** that instantiates **A**
#
# Module **B** instantiates **A** as a hard macro several times.
#
  verilog_b = f"""
module {B}(
    input  wire          clk,
    input  wire[{N}-1:0] a1,
    input  wire[{N}-1:0] b1,
    input  wire[{N}-1:0] a2,
    input  wire[{N}-1:0] b2,
    output reg [{N}-1:0] y
);

    reg[{N}-1:0] d1;
    reg[{N}-1:0] d2;

    {A} D1 (.clk(clk), .a(a1), .b(b1), .y(d1));
    {A} D2 (.clk(clk), .a(a2), .b(b2), .y(d2));
    {A} Y  (.clk(clk), .a(d1), .b(d2), .y(y));
endmodule
"""

  with open(file_b, "w") as f:
    f.write(verilog_b)
#
# ## Step 5: Build **B** with **A** as a Custom Library
#
# Configure siliconCompiler to treat ``modA`` as an available macro
# in the ``ASIC`` flow for **B**.
#
  design_b = Design(B)

  design_b.set_dataroot(B, __file__)
  design_b.add_file(f"{B}.v", fileset='verilog')
  design_b.set_topmodule(B, fileset='verilog')

  project_b = ASIC(design_b)
#
# Setting core and die area correctly is crucial for successful macro placement.
#
  project_b.constraint.area.set_diearea_rectangle(SIZE, SIZE)                   # Silicon area occupied by the design
  project_b.constraint.area.set_corearea_rectangle(SIZE-BORDER*2, SIZE-BORDER*2, (BORDER, BORDER))

  project_b.add_fileset(['verilog'])
  project_b.add_asiclib(ModA(project_a))                                        # Add the hard macro for module A
  skywater130_demo(project_b)                                                   # Technology being used

  project_b.run()
  project_b.summary()
#
# ## Conclusion
#
# This tutorial demonstrates how to perform a basic modular hierarchical ``ASIC`` design flow in
# siliconCompiler by:
#
# - Hardening a leaf module **A**
# - Exporting the layout and timing views from **A** as a custom library ``modA``
# - Instantiating ``modA`` in the parent module **B**
#
# This approach enables scalable chip design with reusable hardened blocks.
#
