# Instantiating a hardened module **A** twice in a module **B**

Hardened modules allow predictable timing, efficient placement, and scalable
hierarchical ASIC design.

This tutorial demonstrates how to use siliconCompiler to harden a
verilog module as a reusable macro, and then instantiate it multiple times in
another module by:

1. Writing a simple verilog module **A**
2. Synthesizing, placing, and routing **A** using siliconCompiler
3. Packaging the resulting layout and timing models from **A** as a hard macro
4. Instantiating the hard macro **A** twice inside a second module **B**
5. Running the ASIC flow on module **B**

All these steps are contained in the single python script detailed below.

To  run this script:

```
docker run --rm -v "$(pwd):/sc_work" ghcr.io/siliconcompiler/sc_runner:v0.35.3 python3 silicon_compiler_mod_A_in_mod_B.py
```

The output will appear in: ``./build/B/job0/write.gds/0/outputs/B.png``

## Environment Setup

Import the tools to be used:


## Parameters

These parameters determine the size of the design and the names of the
modules in the design.


## Files used

These files will contain the verilog generated by this script.


## Step 1: Create Verilog for module **A**

**A** is a simple ``AND`` gate with a registered output triggered by the clock.


## Step 2: Synthesize, Place & Route module **A**

The following code will build module **A** with the siliconCompiler default
``ASIC`` flow:


## Step 3: Create a Macro Library Class from **A**

Take the generated ``LEF``, ``GDS``, and ``Liberty`` files and package them into a
custom library class so **A** can be instantiated as a hard macro.

Define a class that inherits from the relevant tools and
provides them with the locations of the files generated by siliconCompiler
during the processing of module **A**.


## Step 4: Create Verilog for a module **B** that instantiates **A**

Module **B** instantiates **A** as a hard macro several times.


## Step 5: Build **B** with **A** as a Custom Library

Configure siliconCompiler to treat ``modA`` as an available macro
in the ``ASIC`` flow for **B**.


Setting core and die area correctly is crucial for successful macro placement.


## Conclusion

This tutorial demonstrates how to perform a basic modular hierarchical ``ASIC`` design flow in
siliconCompiler by:

- Hardening a leaf module **A**
- Exporting the layout and timing views from **A** as a custom library ``modA``
- Instantiating ``modA`` in the parent module **B**

This approach enables scalable chip design with reusable hardened blocks.

