.. _hardened_modules:

Instantiating a hardened module in a design
===========================================

Hardened modules allow predictable timing, efficient placement, and scalable hierarchical ASIC design.

This tutorial demonstrates how to use Silicon Compiler to harden a Verilog module as a reusable macro, and then instantiate it multiple times in another module by:

1. Setup design
2. Synthesizing, placing, and routing **mod_and** using Silicon Compiler
3. Packaging the resulting layout and timing models from **mod_and** as a hard macro
4. Running the ASIC flow on module **top**

All these steps are contained in the `python script <https://github.com/siliconcompiler/siliconcompiler/blob/main/examples/macro_reuse/make.py>`_.

To run this script from its containing folder:

.. code-block:: bash

    smake build_top

or to use docker:

.. code-block:: bash

    docker run --rm -v "$(pwd):/sc_work" \
        ghcr.io/siliconcompiler/sc_runner:latest \
        python3 make.py

The image output will appear in: ``./build/top/job0/write.gds/0/outputs/top.png``

Environment Setup
-----------------

Import the modules to be used:

.. literalinclude:: examples/macro_reuse/make.py
    :language: python
    :lines: 19-20


Files used
----------

.. literalinclude:: examples/macro_reuse/and.v
    :caption: and.v
    :language: verilog

.. literalinclude:: examples/macro_reuse/top.v
    :caption: top.v
    :language: verilog

Step 1: Setup design
--------------------

The following code will build module **mod_and** and **top** with the default :ref:`ASIC <schema-siliconcompiler-flows-asicflow-asicflow>` flow:

.. literalinclude:: examples/macro_reuse/make.py
    :language: python
    :caption: Design setup for mod_and
    :lines: 23-33

.. literalinclude:: examples/macro_reuse/make.py
    :language: python
    :caption: Design setup for top
    :lines: 36-48

Dependency graph from **top**:

.. figure:: _images/hardended/depgraph.png
    :align: center

    Dependency graph from ``Top().write_depgraph``

Step 2: Synthesize, Place & Route module **mod_and**
----------------------------------------------------

The following code will build module **mod_and** with the default :ref:`ASIC <schema-siliconcompiler-flows-asicflow-asicflow>` flow:

.. literalinclude:: examples/macro_reuse/make.py
    :language: python
    :lines: 51-68

.. figure:: _images/hardended/and.png
    :align: center
    :scale: 50%

Step 3: Packaging the resulting layout and timing models from **mod_and** as a hard macro
-----------------------------------------------------------------------------------------

Take the generated ``LEF``, ``GDS``, and ``Liberty`` files and package them into a custom library class so **mod_and** can be instantiated as a hard macro.

Define a class that inherits from the relevant tools and provides them with the locations of the files generated by Silicon Compiler during the processing of module **mod_and**.

.. literalinclude:: examples/macro_reuse/make.py
    :language: python
    :lines: 70-93

Step 4: Running the ASIC flow on module **top**
-----------------------------------------------

Configure Silicon Compiler to treat ``modA`` as an available macro in the :ref:`ASIC <schema-siliconcompiler-flows-asicflow-asicflow>` flow for **top**.

.. literalinclude:: examples/macro_reuse/make.py
    :language: python
    :lines: 96-123

Setting core and die area correctly is crucial for successful macro placement.

.. literalinclude:: examples/macro_reuse/make.py
    :language: python
    :lines: 119

.. figure:: _images/hardended/top.png
    :align: center
    :scale: 50%

Conclusion
----------

This tutorial demonstrates how to perform a basic modular hierarchical :ref:`ASIC <schema-siliconcompiler-flows-asicflow-asicflow>` design flow in Silicon Compiler by:

- Hardening a leaf module **mod_and**
- Exporting the layout and timing views from **mod_and** as a custom library ``module_and``
- Instantiating ``module_and`` in the parent module **top**

This approach enables scalable chip design with reusable hardened blocks.
